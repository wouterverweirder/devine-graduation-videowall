<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VideoWall</title>
  <link rel="stylesheet" href="js/three.js/editor/css/main.css">
  <style>
    #app {
      position: absolute;
      top: 0;
      left: 0;
      /* for 4x2 FullHD */
      width: 7680px;
      height: 2160px;
      /* transform to fit screen */
      /* transform: scale3d(0.2, 0.2, 1.0); */
      transform-origin: top left;
      background: #cccccc;
    }

    video {
      display: none;
    }
  </style>
</head>
<body>
  <div id="app">
    <canvas id="output-canvas"></canvas>
  </div>
  <video id="video-1" muted loop></video>
  <script type="module">

    import * as THREE from './js/three.js/build/three.module.js';
    import loadImage from './js/functions/loadImage.js';

    let config;

    const outputCanvas = document.getElementById('output-canvas');
    
    let renderer, scene;
    let planes;

    const video1 = {
      $video: document.getElementById('video-1'),
    };
    
    const getPlaneScale = (plane, view) => {
      let rotation = 0;
      if (view.config.camera.rotation) {
        rotation = view.config.camera.rotation;
      }
      const size = view.config.camera.size;
      const halfFrustrumSize = size.width / 2;
      const aspect = size.width / size.height;
      // dirty fix, just assume 90 degrees when non-zero
      if (rotation === 0) {
        return {
          x: halfFrustrumSize * config.aspectRatio,
          y: halfFrustrumSize
        }
      }
      return {
        y: halfFrustrumSize * config.aspectRatio,
        x: halfFrustrumSize
      }
    };

    const loadConfig = async () => {
      return await (await fetch('config.json')).json();
    };

    const initCameras = () => {
      for ( let ii = 0; ii < config.views.length; ++ ii ) {
        const view = config.views[ ii ];

        const size = view.config.camera.size;

        const halfFrustrumSize = size.width / 2;
        const aspect = size.width / size.height;

        let rotation = 0;
        if (view.config.camera.rotation) {
          rotation = view.config.camera.rotation;
        }

        const left = 0.5 * halfFrustrumSize * aspect / - 1;
        const right = 0.5 * halfFrustrumSize * aspect;
        const top = halfFrustrumSize / 2;
        const bottom = halfFrustrumSize / - 2;
        const near = 1;
        const far = 30;
        
        const camera = new THREE.OrthographicCamera( left, right, top, bottom, near, far );
        camera.name = `Camera ${ii}`;
        camera.position.fromArray( view.config.camera.position );
        camera.rotation.z = rotation;
        view.camera = camera;

        view.background = new THREE.Color(1, 1, 1);
      }
    };

    const init = async () => {

      config = await loadConfig();

      outputCanvas.width = config.appDimensions.width;
      outputCanvas.height = config.appDimensions.height;

      initCameras();

      renderer = new THREE.WebGLRenderer({canvas: outputCanvas, powerPreference: "high-performance"});
      scene = new THREE.Scene();

      video1.$video.src = 'assets/devine_reel_2020.mp4';
      video1.$video.play();

      const light = new THREE.AmbientLight( 0xffffff );
      scene.add(light);

      planes = [];
      for (let i = 0; i < config.views.length; i++) {

        const view = config.views[i];

        const width = Math.floor( config.appDimensions.width * view.config.output.width );
        const height = Math.floor( config.appDimensions.height * view.config.output.height );

        let texture;
        let textureType = assetsPerScreen[i].type;

        if (textureType === 'video') {
          texture = new THREE.VideoTexture(video1.$video);
        } else if (textureType === 'image') {
          // texture = new THREE.TextureLoader().load( assetsPerScreen[i].url );
          const planeCanvas = new OffscreenCanvas(width, height)
          const planeCtx = planeCanvas.getContext('2d');
          // draw the image in the center of the plane
          const image = await loadImage(assetsPerScreen[i].url);
          const offsetX = (width - image.width) / 2;
          const offsetY =(height - image.height) / 2;
          planeCtx.drawImage(image, offsetX, offsetY);
          texture = new THREE.CanvasTexture(planeCanvas);
        } else {
          const planeCanvas = new OffscreenCanvas(width, height)
          const planeCtx = planeCanvas.getContext('2d');
          planeCtx.fillStyle = `rgba(${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}`;
          planeCtx.fillRect(0, 0, planeCanvas.width, planeCanvas.height);
          texture = new THREE.CanvasTexture(planeCanvas);
        }
        const material = new THREE.MeshBasicMaterial( { map: texture } );
        const planeGeometry = new THREE.PlaneBufferGeometry(1, 1, 1, 1);
        const plane = new THREE.Mesh(planeGeometry, material);
        scene.add(plane);

        // place it on a certain config.views camera
        const targetView = config.views[i];
        plane.position.x = targetView.camera.position.x;
        plane.position.y = targetView.camera.position.y;
        plane.position.z = i;

        const scale = getPlaneScale(plane, view);
        plane.scale.set(scale.x, scale.y);
        
        const textureAspectRatio = scale.x / scale.y;
        texture.repeat.x = textureAspectRatio / config.aspectRatio;
        texture.offset.x = (1 - texture.repeat.x) / 2;

        plane.userData.textureType = textureType;
        plane.userData.targetX = plane.position.x;
        plane.userData.targetY = plane.position.y;
        plane.userData.targetScaleX = plane.scale.x;
        plane.userData.targetScaleY = plane.scale.y;
        plane.userData.targetTextureRepeatX = texture.repeat.x;
        plane.userData.targetTextureOffsetX = texture.offset.x;

        planes.push(plane);
      }

      requestAnimationFrame(render);
    };

    const updateViews = () => {
      planes.forEach((plane) => {

        if (plane.userData.textureType === 'canvas') {
          const canvasTexture = plane.material.map;
          const planeCanvas = canvasTexture.image;
          const planeCtx = planeCanvas.getContext('2d');
          // planeCtx.fillStyle = `rgba(${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}`;
          // planeCtx.fillRect(0, 0, planeCanvas.width, planeCanvas.height);
          canvasTexture.needsUpdate = true;
        }

        const moveSpeed = 0.2;

        plane.position.x += (plane.userData.targetX - plane.position.x) * moveSpeed;
        plane.position.y += (plane.userData.targetY - plane.position.y) * moveSpeed;

        plane.scale.x += (plane.userData.targetScaleX - plane.scale.x) * moveSpeed;
        plane.scale.y += (plane.userData.targetScaleY - plane.scale.y) * moveSpeed;

        plane.material.map.repeat.x += (plane.userData.targetTextureRepeatX - plane.material.map.repeat.x) * moveSpeed;
        plane.material.map.offset.x += (plane.userData.targetTextureOffsetX - plane.material.map.offset.x) * moveSpeed;

      });
    };

    const renderCameras = () => {
      for ( let ii = 0; ii < config.views.length; ++ ii ) {
        const view = config.views[ ii ];

        const left = Math.floor( config.appDimensions.width * view.config.output.left );
        const bottom = Math.floor( config.appDimensions.height * view.config.output.bottom );
        const width = Math.floor( config.appDimensions.width * view.config.output.width );
        const height = Math.floor( config.appDimensions.height * view.config.output.height );

        renderer.setViewport( left, bottom, width, height );
        renderer.setScissor( left, bottom, width, height );
        renderer.setScissorTest( true );
        renderer.setClearColor( view.background );

        renderer.render( scene, view.camera );
      }
    };

    const render = (time) => {
 
      updateViews();
      renderCameras();
        
      requestAnimationFrame(render);
    };

    init();

    
  </script>
</body>
</html>