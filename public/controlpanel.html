<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VideoWall</title>
  <link rel="stylesheet" href="js/three.js/editor/css/main.css">
  <link rel="stylesheet" href="css/controlpanel.css">
  <style>

    /* #editor-container, #viewport {
      position: absolute;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
    } */
  </style>
</head>
<body>
  <div id="editor-container">
  </div>
  <div id="sidebar-container"></div>
  <script src="js/three.js/editor/js/libs/signals.min.js"></script>
  <script type="module">

    import * as THREE from './js/three.js/build/three.module.js';
    import { ServerConnection } from './js/classes/ServerConnection.js';
    import createCamerasForConfig from './js/functions/createCamerasForConfig.js';
    import createPlaneForScreen from './js/functions/createPlaneForScreen.js';

    import { Editor } from './js/three.js/editor/js/Editor.js';
    import { Sidebar } from './js/classes/Sidebar.js';
    import { Viewport } from './js/three.js/editor/js/Viewport.js';
    Number.prototype.format = function () {
      return this.toString().replace( /(\d)(?=(\d{3})+(?!\d))/g, "$1," );
    };
    
    const $editorContainer = document.getElementById('editor-container');

    const BLACK = new THREE.Color(1, 1, 1);
    
    let config;
    let renderer, scene;
    let cameras;
    const screensById = {};
    const camerasById = {};
    let objects = [];
    let editor;
    const editorCamerasById = {};
    
    const serverConnection = new ServerConnection();
    let messageQueue = Promise.resolve();

    const loadConfig = async () => {
      return await (await fetch('config.json')).json();
    };

    const init = async () => {

      config = await loadConfig();
      config.screens.forEach(screen => screensById[screen.id] = screen);

      cameras = createCamerasForConfig(config);
      cameras.forEach(camera => camerasById[camera.userData.id] = camera);

      renderer = new THREE.WebGLRenderer({powerPreference: "high-performance"});
      scene = new THREE.Scene();

      editor = new Editor();
      editor.serverConnection = serverConnection;
      let serverAddress = editor.config.getKey('serverAddress');
      if (!serverAddress) {
        serverAddress = '127.0.0.1';
        editor.config.setKey('serverAddress', serverAddress);
      }
      editor.camera.position.fromArray([23, 66, 37]);
      editor.camera.lookAt(0, 0, 0);

      const Signal = signals.Signal;

      const viewport = new Viewport( editor );
      $editorContainer.appendChild( viewport.dom );

      const sidebar = new Sidebar( editor );
			document.body.appendChild( sidebar.dom );
      
      const editorRenderer = new THREE.WebGLRenderer( { antialias: false } );
      editor.signals.configChanged = new Signal();
      // 
      // request signals
      editor.signals.requestRemoveObject = new Signal();
      //
      editor.signals.rendererChanged.dispatch( editorRenderer );
      editor.signals.windowResize.dispatch();

      editor.signals.configChanged.add(() => {
        saveConfigs();
      });

      // const light = new THREE.AmbientLight( 0xffffff );
      // scene.add(light);

      // clone children into the editor and link it together
      scene.children.forEach(child => {
        addChildToEditor(child);
      });

      // cameras
      cameras.forEach(camera => {
        const screen = screensById[camera.userData.id];
        
        const clonedCamera = camera.clone();
        editorCamerasById[camera.userData.id] = clonedCamera;
        editor.addObject(clonedCamera);
        const cameraHelper = editor.helpers[clonedCamera.id];

        const onChange = () => {
          // update the config
          screen.camera.position[0] = clonedCamera.position.x;
          screen.camera.position[1] = clonedCamera.position.y;
          screen.camera.position[2] = clonedCamera.position.z;
          camera.position.copy(clonedCamera.position);
          camera.quaternion.copy(clonedCamera.quaternion);
          camera.updateProjectionMatrix();
          clonedCamera.updateProjectionMatrix();
          cameraHelper.update();
        };
        clonedCamera.userData.onChange = onChange;
        onChange();
      });
      editor.signals.objectSelected.add((object) => {
        if (!object) {
          return;
        }
        if (!object.userData.onChange) {
          return;
        }
      });
      editor.signals.refreshSidebarObject3D.add((object) => {
        if (!object.userData.onChange) {
          return;
        }
        // trigger the onChange
        object.userData.onChange();
        editor.signals.configChanged.dispatch();
      });
      // request signals
      editor.signals.requestRemoveObject.add((userData) => {
        serverConnection.requestRemoveObject(userData);
      });
     
      document.addEventListener('keydown', onKeyDown, false );
      window.addEventListener( 'resize', onWindowResize, false );
      onWindowResize();

      serverConnection.onopen = () => {
        serverConnection.requestClearScene();

        serverConnection.requestCreatePlaneOnScreen({ id: THREE.MathUtils.generateUUID(), screenId: 'screen-0', type: 'image', url: 'assets/2532.png' });
        serverConnection.requestCreatePlaneOnScreen({ id: THREE.MathUtils.generateUUID(), screenId: 'screen-1', type: 'image', url: 'assets/2532.png' });
        serverConnection.requestCreatePlaneOnScreen({ id: THREE.MathUtils.generateUUID(), screenId: 'screen-2', type: 'image', url: 'assets/2532.png' });
        serverConnection.requestCreatePlaneOnScreen({ id: THREE.MathUtils.generateUUID(), screenId: 'screen-3', type: 'image', url: 'assets/2532.png' });
        serverConnection.requestCreatePlaneOnScreen({ id: THREE.MathUtils.generateUUID(), screenId: 'screen-4', type: 'image', url: 'assets/2532.png' });
        serverConnection.requestCreatePlaneOnScreen({ id: THREE.MathUtils.generateUUID(), screenId: 'screen-5', type: 'image', url: 'assets/2532.png' });
        serverConnection.requestCreatePlaneOnScreen({ id: THREE.MathUtils.generateUUID(), screenId: 'screen-6', type: 'image', url: 'assets/2532.png' });
        serverConnection.requestCreatePlaneOnScreen({ id: THREE.MathUtils.generateUUID(), screenId: 'screen-7', type: 'image', url: 'assets/2532.png' });
      };

      serverConnection.connect(serverAddress);

      serverConnection.onmessage = (message) => {
        try {
          const parsedMessage = JSON.parse(message.data);
          queueReceivedMessage(parsedMessage);
        } catch (e) {
          console.error(e);
        }
      };

      requestAnimationFrame(render);
    };

    const onWindowResize = (event) => {
      editor.signals.windowResize.dispatch();
    };

    const onKeyDown = (event) => {
      switch ( event.key.toLowerCase() ) {
        case 'backspace':
        case 'delete':
          const object = editor.selected;
          if ( !object ) return;
          if ( !object.userData.type || object.userData.type === 'screen' ) return;

          serverConnection.requestRemoveObject(object.userData);
          editor.deselect();
          break;
      }
    };

    const queueReceivedMessage = (parsedMessage) => {
      if (parsedMessage.type) {
        if (parsedMessage.type === 'create-plane-on-screen') {
          messageQueue = messageQueue.then(() => onRequestCreatePlaneOnScreen(parsedMessage.userData));
        } else if (parsedMessage.type === 'clear-scene') {
          messageQueue = messageQueue.then(() => onRequestClearScene());
        } else if (parsedMessage.type === 'remove-object') {
          messageQueue = messageQueue.then(() => onRequestRemoveObject(parsedMessage.userData));
        }
      }
    }

    const onRequestClearScene = () => {
      objects.forEach(object => {
        scene.remove(object);
        if (object.userData.editorChild) {
          editor.removeObject(object.userData.editorChild);
        }
      });
      objects = [];
    };

    const onRequestCreatePlaneOnScreen = async (userData) => {
      const screen = screensById[userData.screenId];
      if (!screen) {
        return;
      }
      const plane = await createPlaneForScreen({userData, screen, appConfig: config});
      scene.add(plane);
      objects.push(plane);
      addChildToEditor(plane);
    };

    const onRequestRemoveObject = async (userData) => {
      let applicableObjects = objects.filter(object => {
        return object.userData.id === userData.id
      });
      applicableObjects.forEach(object => {
        scene.remove(object);
        let index = objects.indexOf(object);
        if (index > -1) {
          objects.splice(index, 1);
        }
        if (object.userData.editorChild) {
          editor.removeObject(object.userData.editorChild);
        }
      });
    };

    const addChildToEditor = (child) => {
      const clonedChild = child.clone();
      clonedChild.userData.onChange = () => {
        child.position.copy(clonedChild.position);
        child.quaternion.copy(clonedChild.quaternion);
      }
      child.userData.editorChild = clonedChild;
      child.userData.onChange = () => {
        clonedChild.position.copy(child.position);
        clonedChild.quaternion.copy(child.quaternion);
        clonedChild.scale.copy(child.scale);
      };
      editor.addObject(clonedChild);
    };

    const saveConfigs = () => {
      const json = {...config};
      serverConnection.sendRequest({
        type: 'save-config',
        json
      });
    };

    const updateObjects = () => {
      objects.forEach((object) => {
        if (object.userData.type === 'canvas') {
          const canvasTexture = object.material.map;
          const planeCanvas = canvasTexture.image;
          const planeCtx = planeCanvas.getContext('2d');
          // planeCtx.fillStyle = `rgba(${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}`;
          // planeCtx.fillRect(0, 0, planeCanvas.width, planeCanvas.height);
          canvasTexture.needsUpdate = true;
        }
        object.userData.onChange();
      });
    };

    const renderCameras = () => {
      cameras.forEach(camera => {
        const screen = screensById[camera.userData.id];

        const left = Math.floor( config.appDimensions.width * screen.output.left );
        const bottom = Math.floor( config.appDimensions.height * screen.output.bottom );
        const width = Math.floor( config.appDimensions.width * screen.output.width );
        const height = Math.floor( config.appDimensions.height * screen.output.height );

        renderer.setViewport( left, bottom, width, height );
        renderer.setScissor( left, bottom, width, height );
        renderer.setScissorTest( true );
        renderer.setClearColor( BLACK );

        renderer.render( scene, camera );
      })
    };

    const render = (time) => {
 
      updateObjects();
      renderCameras();

      editor.signals.applicationRendered.dispatch();
        
      requestAnimationFrame(render);
    };

    init();

    
  </script>
</body>
</html>