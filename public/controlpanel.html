<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VideoWall</title>
  <link rel="stylesheet" href="js/three.js/editor/css/main.css">
  <style>

    #editor-container, #viewport {
      position: absolute;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
    }

    video {
      display: none;
    }
  </style>
</head>
<body>
  <div id="editor-container">
  </div>
  <div id="sidebar-container"></div>
  <video id="video-1" muted loop></video>
  <script src="js/three.js/editor/js/libs/signals.min.js"></script>
  <script type="module">

    import * as THREE from './js/three.js/build/three.module.js';
    import createCamerasForConfig from './js/functions/createCamerasForConfig.js';
    import createPlaneForView from './js/functions/createPlaneForView.js';

    import { Editor } from './js/three.js/editor/js/Editor.js';
    import { Viewport } from './js/three.js/editor/js/Viewport.js';
    Number.prototype.format = function () {
      return this.toString().replace( /(\d)(?=(\d{3})+(?!\d))/g, "$1," );
    };
    
    const $editorContainer = document.getElementById('editor-container');
    
    let config;
    let renderer, scene;
    const planes = [];
    let editor;

    const video1 = {
      $video: document.getElementById('video-1'),
    };

    const loadConfig = async () => {
      return await (await fetch('config.json')).json();
    };

    const init = async () => {

      config = await loadConfig();

      createCamerasForConfig(config);

      renderer = new THREE.WebGLRenderer({powerPreference: "high-performance"});
      scene = new THREE.Scene();

      editor = new Editor();
      editor.camera.position.fromArray([23, 66, 37]);
      editor.camera.lookAt(0, 0, 0);

      const viewport = new Viewport( editor );
      $editorContainer.appendChild( viewport.dom );
      
      const editorRenderer = new THREE.WebGLRenderer( { antialias: false } );
      editor.signals.rendererChanged.dispatch( editorRenderer );
      editor.signals.windowResize.dispatch();

      video1.$video.src = 'assets/devine_reel_2020.mp4';
      video1.$video.play();

      const light = new THREE.AmbientLight( 0xffffff );
      scene.add(light);

      // quick setup asset to a certain screen
      const assetsPerScreen = [
        { type: 'image', url: 'assets/2532.png' },
        { type: 'image', url: 'assets/2532.png' },
        { type: 'image', url: 'assets/2532.png' },
        { type: 'image', url: 'assets/2532.png' },
        { type: 'image', url: 'assets/2532.png' },
        { type: 'image', url: 'assets/2532.png' },
        { type: 'image', url: 'assets/2532.png' },
        { type: 'image', url: 'assets/2532.png' }
      ];

      for (let i = 0; i < config.views.length; i++) {
        const view = config.views[i];
        const plane = await createPlaneForView(assetsPerScreen[i], view, config);
        plane.position.z = i;
        scene.add(plane);
        planes.push(plane);
      }

      // clone children into the editor and link it together
      scene.children.forEach(child => {
        const clonedChild = child.clone();
        clonedChild.userData.onChange = () => {
          child.position.copy(clonedChild.position);
          child.quaternion.copy(clonedChild.quaternion);
        }
        child.userData.editorChild = clonedChild;
        child.userData.onChange = () => {
          clonedChild.position.copy(child.position);
          clonedChild.quaternion.copy(child.quaternion);
          clonedChild.scale.copy(child.scale);
        };
        editor.addObject(clonedChild);
      });

      // cameras
      for ( let ii = 0; ii < config.views.length; ++ ii ) {
        // camera
        const view = config.views[ ii ];
        const clonedCamera = view.camera.clone();
        editor.addObject(clonedCamera);
        const cameraHelper = editor.helpers[clonedCamera.id];

        const onChange = () => {
          // update the config
          view.config.camera.position[0] = clonedCamera.position.x;
          view.config.camera.position[1] = clonedCamera.position.y;
          view.config.camera.position[2] = clonedCamera.position.z;
          view.camera.position.copy(clonedCamera.position);
          view.camera.quaternion.copy(clonedCamera.quaternion);
          view.camera.updateProjectionMatrix();
          clonedCamera.updateProjectionMatrix();
          cameraHelper.update();
        };
        clonedCamera.userData.onChange = onChange;
        onChange();
      }
      editor.signals.objectSelected.add((object) => {
        if (!object) {
          return;
        }
        if (!object.userData.onChange) {
          return;
        }
        console.log(object);
      });
      editor.signals.refreshSidebarObject3D.add((object) => {
        if (!object.userData.onChange) {
          return;
        }
        // trigger the onChange
        object.userData.onChange();
        // save the config
        saveConfigs();
      });

      function onWindowResize() {
        editor.signals.windowResize.dispatch();
      }
      
      window.addEventListener( 'resize', onWindowResize, false );
      onWindowResize();

      requestAnimationFrame(render);
    };

    const saveConfigs = () => {
      // config.views contains other, non-json properties now
      // just keep the json properties
      const json = {...config};
      json.views = [];
      config.views.forEach(view => {
        const config = {...view.config};
        json.views.push({ config });
      });
      if (window.api && window.api.send) {
        window.api.send("toMain", { type: 'saveConfigs', json });
      }
    };

    const updateViews = () => {
      planes.forEach((plane) => {

        if (plane.userData.planeConfig.type === 'canvas') {
          const canvasTexture = plane.material.map;
          const planeCanvas = canvasTexture.image;
          const planeCtx = planeCanvas.getContext('2d');
          // planeCtx.fillStyle = `rgba(${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}`;
          // planeCtx.fillRect(0, 0, planeCanvas.width, planeCanvas.height);
          canvasTexture.needsUpdate = true;
        }

        const moveSpeed = 0.2;

        plane.position.x += (plane.userData.targetX - plane.position.x) * moveSpeed;
        plane.position.y += (plane.userData.targetY - plane.position.y) * moveSpeed;

        plane.scale.x += (plane.userData.targetScaleX - plane.scale.x) * moveSpeed;
        plane.scale.y += (plane.userData.targetScaleY - plane.scale.y) * moveSpeed;

        plane.material.map.repeat.x += (plane.userData.targetTextureRepeatX - plane.material.map.repeat.x) * moveSpeed;
        plane.material.map.offset.x += (plane.userData.targetTextureOffsetX - plane.material.map.offset.x) * moveSpeed;

        plane.userData.onChange();

      });
    };

    const renderCameras = () => {
      for ( let ii = 0; ii < config.views.length; ++ ii ) {
        const view = config.views[ ii ];

        const left = Math.floor( config.appDimensions.width * view.config.output.left );
        const bottom = Math.floor( config.appDimensions.height * view.config.output.bottom );
        const width = Math.floor( config.appDimensions.width * view.config.output.width );
        const height = Math.floor( config.appDimensions.height * view.config.output.height );

        renderer.setViewport( left, bottom, width, height );
        renderer.setScissor( left, bottom, width, height );
        renderer.setScissorTest( true );
        renderer.setClearColor( view.background );

        renderer.render( scene, view.camera );
      }
    };

    const render = (time) => {
 
      updateViews();
      renderCameras();

      editor.signals.applicationRendered.dispatch();
        
      requestAnimationFrame(render);
    };

    init();

    
  </script>
</body>
</html>